Metadata-Version: 2.4
Name: qcgm
Version: 0.1.0
Summary: Quantum Circuits for Discrete Graphical Models
Home-page: https://github.com/yourusername/qcgm
Author: Based on Piatkowski & Zoufal (2022)
Author-email: your.email@example.com
Project-URL: Documentation, https://github.com/yourusername/qcgm
Project-URL: Source, https://github.com/yourusername/qcgm
Project-URL: Paper, https://arxiv.org/abs/2206.00398
Keywords: quantum computing,graphical models,quantum circuits,sampling,qiskit
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Science/Research
Classifier: Topic :: Scientific/Engineering :: Physics
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Requires-Dist: numpy>=1.20.0
Requires-Dist: qiskit>=1.0.0
Requires-Dist: qiskit-aer>=0.13.0
Requires-Dist: scipy>=1.7.0
Provides-Extra: viz
Requires-Dist: matplotlib<4.0.0,>=3.5.0; extra == "viz"
Requires-Dist: networkx<4.0.0,>=2.5; extra == "viz"
Requires-Dist: seaborn<1.0.0,>=0.11.0; extra == "viz"
Requires-Dist: qiskit-ibm-runtime>=0.15.0; extra == "viz"
Provides-Extra: notebooks
Requires-Dist: jupyter>=1.0.0; extra == "notebooks"
Requires-Dist: ipywidgets>=7.7.0; extra == "notebooks"
Requires-Dist: notebook>=6.4.0; extra == "notebooks"
Requires-Dist: jupyterlab>=3.4.0; extra == "notebooks"
Provides-Extra: dev
Requires-Dist: pytest<9.0.0,>=7.0.0; extra == "dev"
Requires-Dist: pytest-cov<5.0.0,>=3.0.0; extra == "dev"
Requires-Dist: pytest-mock>=3.10.0; extra == "dev"
Requires-Dist: black<25.0.0,>=22.0.0; extra == "dev"
Requires-Dist: flake8<8.0.0,>=4.0.0; extra == "dev"
Requires-Dist: isort>=5.10.0; extra == "dev"
Requires-Dist: mypy<2.0.0,>=0.950; extra == "dev"
Requires-Dist: sphinx>=4.5.0; extra == "dev"
Requires-Dist: sphinx-rtd-theme>=1.0.0; extra == "dev"
Provides-Extra: all
Requires-Dist: matplotlib<4.0.0,>=3.5.0; extra == "all"
Requires-Dist: networkx<4.0.0,>=2.5; extra == "all"
Requires-Dist: seaborn<1.0.0,>=0.11.0; extra == "all"
Requires-Dist: qiskit-ibm-runtime>=0.15.0; extra == "all"
Requires-Dist: jupyter>=1.0.0; extra == "all"
Requires-Dist: ipywidgets>=7.7.0; extra == "all"
Requires-Dist: notebook>=6.4.0; extra == "all"
Requires-Dist: jupyterlab>=3.4.0; extra == "all"
Requires-Dist: pytest<9.0.0,>=7.0.0; extra == "all"
Requires-Dist: pytest-cov<5.0.0,>=3.0.0; extra == "all"
Requires-Dist: pytest-mock>=3.10.0; extra == "all"
Requires-Dist: black<25.0.0,>=22.0.0; extra == "all"
Requires-Dist: flake8<8.0.0,>=4.0.0; extra == "all"
Requires-Dist: isort>=5.10.0; extra == "all"
Requires-Dist: mypy<2.0.0,>=0.950; extra == "all"
Requires-Dist: sphinx>=4.5.0; extra == "all"
Requires-Dist: sphinx-rtd-theme>=1.0.0; extra == "all"
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: keywords
Dynamic: project-url
Dynamic: provides-extra
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

# Quantum Circuits for Discrete Graphical Models

Implementation of the methods proposed in  
**â€œOn Quantum Circuits for Discrete Graphical Modelsâ€**  
by *Nico Piatkowski* and *Christa Zoufal*.

This repository provides a quantum algorithm for **unbiased and independent sampling**, **learning**, and **inference** from **discrete graphical models** using **quantum circuits**. The approach is compatible with **multi-body interactions** and can be executed on **current quantum hardware**.

---

## ğŸš€ Overview

Graphical models are powerful tools for describing structured, high-dimensional probability distributions.  
Sampling from such modelsâ€”especially those with discrete variablesâ€”poses significant computational challenges.

This project implements a **quantum circuit-based method** that:

- Generates **unbiased, independent samples** from general discrete factor models  
- Embeds graphical models into **unitary operators** with provable guarantees  
- Is compatible with **modern hybrid quantum-classical optimization techniques**  

The algorithmâ€™s **success probability** is independent of the number of variables, and it provides a **unitary Hammersleyâ€“Clifford theorem**, establishing factorization over cliques of the modelâ€™s conditional independence structure.

---

## ğŸ§  Key Features

- âœ… Provably unbiased sampling from discrete graphical models  
- âš™ï¸ Unitary embedding of model factors  
- ğŸ” Hybrid quantum-classical training for parameter learning  
- ğŸ§© Support for multi-body interactions  
- ğŸ§® Runnable on current quantum processors and simulators  
- ğŸ“ˆ Includes experiments on quantum simulation and real hardware  

---

## ğŸ§° Installation

```bash
# Clone this repository
git clone https://github.com/arulrhikm/quantum-graphical-models.git
cd quantum-graphical-models

# Install dependencies
pip install -r requirements.txt
# QCGM: Quantum Circuits for Discrete Graphical Models

[![Python 3.8+](https://img.shields.io/badge/python-3.8+-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A Python library for sampling from discrete graphical models using quantum circuits, based on the paper ["On Quantum Circuits for Discrete Graphical Models"](https://arxiv.org/abs/2206.00398) by Nico Piatkowski and Christa Zoufal (2022).

## ğŸŒŸ Key Features

- **Exact Quantum Circuit Construction**: Build quantum circuits for any discrete graphical model
- **Unbiased Sampling**: No burn-in or mixing time required (unlike MCMC methods)
- **Hammersley-Clifford Factorization**: Automatic factorization over cliques
- **NISQ-Compatible**: Works on current quantum hardware

## ğŸ“‹ Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Core Concepts](#core-concepts)
- [Documentation](#documentation)
- [Examples](#examples)
- [Testing](#testing)
- [Citation](#citation)
- [License](#license)

## ğŸš€ Installation

### Prerequisites

- Python 3.8 or higher
- pip package manager

### Install from source

```bash
# Clone the repository
git clone https://github.com/yourusername/qcgm.git
cd qcgm

# Install dependencies
pip install -r requirements.txt

# Install the package
pip install -e .
```

### Required Dependencies

```
numpy>=1.20.0
qiskit>=0.39.0
qiskit-aer>=0.11.0
scipy>=1.7.0
matplotlib>=3.3.0  # Optional, for visualization
```

## âš¡ Quick Start

### Basic Usage

```python
from qcgm import DiscreteGraphicalModel, QCGMSampler

# Create a graphical model (chain structure: v0 - v1 - v2)
model = DiscreteGraphicalModel(n_vars=3, cliques=[{0, 1}, {1, 2}])
model.set_random_parameters(low=-2.0, high=-0.5)

# Sample using quantum circuit
sampler = QCGMSampler(model)
samples, success_rate = sampler.sample(n_samples=1000)

print(f"Generated {len(samples)} valid samples")
print(f"Success rate: {success_rate:.4f}")
```

### Compare with Exact Distribution

```python
from qcgm.utils import compute_fidelity, estimate_distribution

# Get exact probabilities
exact_probs = model.compute_probabilities()

# Estimate from quantum samples
quantum_probs = estimate_distribution(samples, model.n_vars)

# Compute fidelity
fidelity = compute_fidelity(exact_probs, quantum_probs)
print(f"Fidelity: {fidelity:.6f}")
```

## ğŸ¯ Core Concepts

### Discrete Graphical Models

A discrete graphical model over binary variables is defined by:

```
P_Î¸(X = x) = (1/Z(Î¸)) exp(Î£_{Câˆˆğ’} Î£_{yâˆˆğ’³_C} Î¸_{C,y} Ï†_{C,y}(x))
```

where:
- `ğ’` is the set of maximal cliques
- `Î¸` are the canonical parameters
- `Ï†` are the sufficient statistics
- `Z(Î¸)` is the partition function

### Quantum Circuit Construction

The library implements **Theorem 3.4** from the paper, constructing a quantum circuit that:

1. Encodes the probability distribution as quantum amplitudes
2. Uses `n` variable qubits (one per variable)
3. Optionally uses auxiliary qubits for complex models
4. Produces unbiased samples when measured

### Key Advantages

- **No Burn-in Period**: Unlike MCMC methods, quantum sampling provides immediate unbiased samples
- **Exact Representation**: The circuit exactly represents the target distribution
- **Scalability**: Efficient for sparse graphical models with moderate numbers of cliques

## ğŸ“š Documentation

### Main Classes

#### `DiscreteGraphicalModel`

Represents a discrete graphical model over binary variables.

```python
model = DiscreteGraphicalModel(n_vars=3, cliques=[{0, 1}, {1, 2}])

# Set parameters
model.set_random_parameters(low=-5.0, high=0.0, seed=42)

# Compute exact probabilities
probs = model.compute_probabilities()

# Generate classical samples (for comparison)
classical_samples = model.sample_exact(n_samples=1000)

# Compute entropy
entropy = model.compute_entropy()
```

#### `QuantumCircuitBuilder`

Constructs quantum circuits for graphical models.

```python
from qcgm import QuantumCircuitBuilder

# Build circuit (simplified version, recommended)
circuit = QuantumCircuitBuilder.build_circuit_simplified(model)

# Or build with auxiliary qubits
circuit = QuantumCircuitBuilder.build_circuit(model, use_aux=True)

# Get circuit depth estimate
depth = QuantumCircuitBuilder.circuit_depth_estimate(model)
```

#### `QCGMSampler`

Main interface for quantum sampling.

```python
sampler = QCGMSampler(model)

# Basic sampling
samples, success_rate = sampler.sample(n_samples=1000, simplified=True)

# Sampling with automatic retry
samples, info = sampler.sample_with_retry(
    target_samples=500,
    max_shots=10000
)

# Get circuit statistics
stats = sampler.get_circuit_stats()
print(f"Circuit depth: {stats['depth']}")
print(f"Number of qubits: {stats['num_qubits']}")
```

### Utility Functions

#### Distribution Analysis

```python
from qcgm.utils import (
    compute_fidelity,
    hellinger_distance,
    kl_divergence,
    total_variation_distance,
    compare_distributions,
    print_comparison
)

# Compare two distributions
metrics = compare_distributions(exact_probs, quantum_probs, 
                                labels=('Exact', 'Quantum'))
print_comparison(metrics)

# Individual metrics
fidelity = compute_fidelity(p, q)
hellinger = hellinger_distance(p, q)
kl = kl_divergence(p, q)
tv = total_variation_distance(p, q)
```

#### Sample Statistics

```python
from qcgm.utils import sample_statistics

stats = sample_statistics(samples)
print(f"Unique samples: {stats['n_unique']}")
print(f"Empirical entropy: {stats['empirical_entropy']:.4f}")
```

### Convenience Functions

#### Create Common Structures

```python
from qcgm import (
    create_chain_model,
    create_star_model,
    create_complete_model,
    create_tree_model
)

# Chain: v0 - v1 - v2 - v3
chain = create_chain_model(n_vars=4, low=-2.0, high=-0.5)

# Star: center connected to all others
star = create_star_model(n_vars=5, center=0)

# Complete graph (warning: expensive!)
complete = create_complete_model(n_vars=4)

# Tree from edges
edges = [(0, 1), (0, 2), (1, 3), (1, 4)]
tree = create_tree_model(edges)
```

## ğŸ“– Examples

### Example 1: Simple Two-Variable Model

```python
import numpy as np
from qcgm import DiscreteGraphicalModel, QCGMSampler
from qcgm.utils import compute_fidelity, estimate_distribution

# Create model with one clique
model = DiscreteGraphicalModel(2, [{0, 1}])
model.set_random_parameters(seed=42)

# Get exact distribution
exact_probs = model.compute_probabilities()

# Sample from quantum circuit
sampler = QCGMSampler(model)
samples, _ = sampler.sample(n_samples=5000, simplified=True)

# Compare
quantum_probs = estimate_distribution(samples, 2)
fidelity = compute_fidelity(exact_probs, quantum_probs)

print(f"Fidelity: {fidelity:.6f}")  # Should be > 0.99
```

### Example 2: Chain Model with Visualization

```python
import matplotlib.pyplot as plt
from qcgm import create_chain_model, QCGMSampler
from qcgm.utils import estimate_distribution, generate_state_labels

# Create chain model
model = create_chain_model(n_vars=3, low=-3.0, high=-0.1)

# Sample
sampler = QCGMSampler(model)
samples, _ = sampler.sample(n_samples=10000, simplified=True)

# Get distributions
exact_probs = model.compute_probabilities()
quantum_probs = estimate_distribution(samples, 3)

# Plot
labels = generate_state_labels(3)
x = np.arange(len(labels))
width = 0.35

fig, ax = plt.subplots(figsize=(10, 6))
ax.bar(x - width/2, exact_probs, width, label='Exact', alpha=0.8)
ax.bar(x + width/2, quantum_probs, width, label='Quantum', alpha=0.8)

ax.set_xlabel('State')
ax.set_ylabel('Probability')
ax.set_title('Exact vs Quantum Sampling')
ax.set_xticks(x)
ax.set_xticklabels(labels)
ax.legend()
plt.show()
```

## ğŸ§ª Testing

### Quick Circuit Test

```python
from qcgm.circuit import quick_test

# Run quick verification
success = quick_test()  # Should print "âœ“ SUCCESS!"
```

### Check Dependencies

```python
from qcgm import check_dependencies, print_dependency_status

# Print dependency status
print_dependency_status()

# Get status dictionary
status = check_dependencies()
```

## ğŸ“Š Performance Considerations

### Success Rate

The success probability Î´* decreases exponentially with the number of cliques:

```
Î´* â‰ˆ 1 / 2^|ğ’|
```

For models with many cliques, use `sample_with_retry`:

```python
samples, info = sampler.sample_with_retry(
    target_samples=1000,
    max_shots=50000
)

print(f"Attempts: {info['attempts']}")
print(f"Success rate: {info['success_rate']:.4f}")
```

### Simplified vs Full Circuit

- **Simplified** (recommended): Uses direct state initialization, 100% success rate for state preparation
- **Full**: Uses Hamiltonian decomposition with auxiliary qubits, lower success rate but more general

```python
# Simplified (faster, recommended)
samples, rate = sampler.sample(n_samples=1000, simplified=True)

# Full circuit
samples, rate = sampler.sample(n_samples=1000, simplified=False)
```

## ğŸ”¬ Theory Background

### Algorithm Overview

The QCGM algorithm (Piatkowski & Zoufal, 2022) follows these steps:

1. **Hamiltonian Construction** (Theorem 3.3):
   ```
   H_Î¸ = -Î£_{Câˆˆğ’} Î£_{yâˆˆğ’³_C} Î¸_{C,y} Î¦_{C,y}
   ```

2. **State Preparation** (Theorem 3.4):
   - Prepare quantum state |ÏˆâŸ© such that |âŸ¨x|ÏˆâŸ©|Â² = P_Î¸(x)
   - Uses amplitude encoding for efficient preparation

3. **Measurement**:
   - Measure in computational basis
   - Each measurement yields an unbiased sample from P_Î¸

### Key Theorems

- **Theorem 3.3**: The Hamiltonian H_Î¸ is diagonal with entries -Î¸áµ€Ï†(x)
- **Theorem 3.4**: Circuit construction with n + 1 + |ğ’| qubits
- **Theorem 5.1**: Success probability Î´* and sample complexity

## ğŸ“ Citation

If you use this library in your research, please cite:

```bibtex
@article{piatkowski2022quantum,
  title={On Quantum Circuits for Discrete Graphical Models},
  author={Piatkowski, Nico and Zoufal, Christa},
  journal={arXiv preprint arXiv:2206.00398},
  year={2022}
}
```

## ğŸ¤ Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

### Development Setup

```bash
# Clone repository
git clone https://github.com/yourusername/qcgm.git
cd qcgm

# Install in development mode
pip install -e ".[dev]"

# Run tests
pytest tests/

# Run linting
flake8 qcgm/
black qcgm/
```

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ™ Acknowledgments

- Original paper: Piatkowski, N., & Zoufal, C. (2022). "On Quantum Circuits for Discrete Graphical Models"
- Based on quantum amplitude encoding and Hamiltonian simulation
- Built with Qiskit and Qiskit Aer

## ğŸ“ Contact

- **Issues**: [GitHub Issues](https://github.com/arulrhikm/qcgm/issues)
- **Email**: arulm@andrew.cmu.edu, bryanzha@andrew.cmu.edu
- **Paper**: https://arxiv.org/abs/2206.00398

---
